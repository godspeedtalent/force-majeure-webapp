/**
 * Column Factory Service
 *
 * Generates DataGrid column definitions from database schema metadata.
 * Combines type mapping, relation detection, and customizations to create
 * fully-configured column objects.
 */

import { DataGridColumn } from '../types';
import {
  ColumnMetadata,
  MappedColumn,
  mapColumn,
  generateLabel,
  isSortableType,
  isFilterableType,
  isEditableType,
  getDefaultWidth,
} from './schemaTypeMapper';
import {
  ForeignKeyMetadata,
  DetectedRelation,
  detectRelations,
  isRelationEditable,
} from './relationDetector';
import { logger } from '@force-majeure/shared';

/**
 * Column customization (from database or config)
 */
export interface ColumnCustomization {
  column_key: string;
  custom_label?: string;
  custom_type?: string;
  is_editable?: boolean;
  is_visible_by_default?: boolean;
  is_sortable?: boolean;
  is_filterable?: boolean;
  custom_width?: string;
  display_order?: number;
  render_config?: Record<string, any>;
}

/**
 * Options for column generation
 */
export interface ColumnFactoryOptions {
  /** Table name for logging/context */
  tableName: string;

  /** Column metadata from schema introspection */
  columns: ColumnMetadata[];

  /** Foreign key metadata */
  foreignKeys?: ForeignKeyMetadata[];

  /** Admin-defined customizations */
  customizations?: ColumnCustomization[];

  /** Exclude specific columns */
  excludeColumns?: string[];

  /** Include only specific columns (if provided, only these are included) */
  includeColumns?: string[];

  /** Make all columns readonly */
  readonly?: boolean;

  /** Default visibility for columns */
  defaultVisible?: boolean;
}

/**
 * Generated column with metadata
 */
export interface GeneratedColumn extends DataGridColumn {
  _metadata?: {
    source: 'schema' | 'customization';
    hasRelationComponent: boolean;
    referencedTable?: string;
    postgresType: string;
    isAutoGenerated: boolean;
  };
}

/**
 * Generate a single column definition
 */
function generateColumn(
  mapped: MappedColumn,
  relation: DetectedRelation | null,
  customization?: ColumnCustomization
): GeneratedColumn {
  // Start with base properties from mapped column
  const column: GeneratedColumn = {
    key: mapped.key,
    type: mapped.type,
    label: generateLabel(mapped.key),
    sortable: isSortableType(mapped.type),
    filterable: isFilterableType(mapped.type),
    editable: isEditableType(mapped.type, mapped.readonly),
    readonly: mapped.readonly,
    required: mapped.required,
    width: getDefaultWidth(mapped.type, mapped.key),
  };

  // Apply relation properties if detected
  if (relation) {
    column.isRelation = true;

    // If relation has a component, make it editable
    if (relation.hasComponent && !customization?.is_editable === false) {
      column.editable = isRelationEditable(relation);
    } else {
      // No component available - show as readonly text
      column.editable = false;
      column.readonly = true;
    }
  }

  // Apply customizations (overrides)
  if (customization) {
    if (customization.custom_label) {
      column.label = customization.custom_label;
    }

    if (customization.custom_type) {
      column.type = customization.custom_type as DataGridColumn['type'];
    }

    if (customization.is_editable !== undefined) {
      column.editable = customization.is_editable;
    }

    if (customization.is_sortable !== undefined) {
      column.sortable = customization.is_sortable;
    }

    if (customization.is_filterable !== undefined) {
      column.filterable = customization.is_filterable;
    }

    if (customization.custom_width) {
      column.width = customization.custom_width;
    }
  }

  // Add metadata for debugging/inspection
  column._metadata = {
    source: customization ? 'customization' : 'schema',
    hasRelationComponent: relation?.hasComponent || false,
    referencedTable: relation?.referencedTable,
    postgresType: mapped.postgresType,
    isAutoGenerated: !customization,
  };

  return column;
}

/**
 * Main factory function: Generate columns from schema
 */
export function generateColumnsFromSchema(
  options: ColumnFactoryOptions
): GeneratedColumn[] {
  const {
    tableName,
    columns: columnMetadata,
    foreignKeys = [],
    customizations = [],
    excludeColumns = [],
    includeColumns,
    readonly = false,
    defaultVisible = true,
  } = options;

  logger.info(`Generating columns for table: ${tableName}`, {
    columnCount: columnMetadata.length,
    foreignKeyCount: foreignKeys.length,
    customizationCount: customizations.length,
  });

  // Create customization lookup map
  const customizationMap = new Map<string, ColumnCustomization>();
  customizations.forEach(custom => {
    customizationMap.set(custom.column_key, custom);
  });

  // Detect all relations
  const columnNames = columnMetadata.map(col => col.name);
  const relations = detectRelations(columnNames, foreignKeys);
  const relationMap = new Map<string, DetectedRelation>();
  relations.forEach(rel => {
    relationMap.set(rel.columnKey, rel);
  });

  // Log missing relation components as warnings
  const missingComponents = relations.filter(r => !r.hasComponent);
  if (missingComponents.length > 0) {
    logger.warn(
      `Table ${tableName} has ${missingComponents.length} foreign keys without relation components:`,
      missingComponents.map(r => `${r.columnKey} -> ${r.referencedTable}`)
    );
  }

  // Generate columns
  const generatedColumns: GeneratedColumn[] = [];

  for (const colMeta of columnMetadata) {
    // Check include/exclude filters
    if (excludeColumns.includes(colMeta.name)) {
      continue;
    }

    if (includeColumns && !includeColumns.includes(colMeta.name)) {
      continue;
    }

    // Map column type
    const mapped = mapColumn(colMeta);

    // Apply global readonly override
    if (readonly) {
      mapped.readonly = true;
    }

    // Get relation and customization
    const relation = relationMap.get(colMeta.name) || null;
    const customization = customizationMap.get(colMeta.name);

    // Generate column
    const column = generateColumn(mapped, relation, customization);

    // Apply default visibility (can be overridden by customization)
    if (customization?.is_visible_by_default !== undefined) {
      // Customization specifies visibility
      if (!customization.is_visible_by_default) {
        continue; // Skip invisible columns
      }
    } else if (!defaultVisible) {
      // Global default is invisible
      continue;
    }

    generatedColumns.push(column);
  }

  // Apply custom ordering if specified
  const columnsWithOrder = generatedColumns.map((col, index) => {
    const customization = customizationMap.get(col.key);
    return {
      column: col,
      order: customization?.display_order ?? index,
    };
  });

  // Sort by order
  columnsWithOrder.sort((a, b) => a.order - b.order);

  const finalColumns = columnsWithOrder.map(item => item.column);

  logger.info(`Generated ${finalColumns.length} columns for table: ${tableName}`, {
    withRelations: finalColumns.filter(c => c.isRelation).length,
    editable: finalColumns.filter(c => c.editable).length,
    readonly: finalColumns.filter(c => c.readonly).length,
  });

  return finalColumns;
}

/**
 * Helper: Get column by key
 */
export function getColumnByKey(
  columns: DataGridColumn[],
  key: string
): DataGridColumn | undefined {
  return columns.find(col => col.key === key);
}

/**
 * Helper: Filter visible columns
 */
export function filterVisibleColumns(columns: DataGridColumn[]): DataGridColumn[] {
  // Currently, all returned columns are visible
  // This is for future use with visibility toggle
  return columns;
}

/**
 * Helper: Reorder columns
 */
export function reorderColumns(
  columns: DataGridColumn[],
  order: string[]
): DataGridColumn[] {
  const columnMap = new Map(columns.map(col => [col.key, col]));
  const reordered: DataGridColumn[] = [];

  // Add columns in specified order
  order.forEach(key => {
    const col = columnMap.get(key);
    if (col) {
      reordered.push(col);
      columnMap.delete(key);
    }
  });

  // Add remaining columns that weren't in order array
  columnMap.forEach(col => {
    reordered.push(col);
  });

  return reordered;
}

/**
 * Helper: Merge generated columns with manual overrides
 */
export function mergeWithManualColumns(
  generated: DataGridColumn[],
  manual: DataGridColumn[]
): DataGridColumn[] {
  const manualMap = new Map(manual.map(col => [col.key, col]));
  const merged: DataGridColumn[] = [];

  // Start with generated columns, applying manual overrides
  generated.forEach(genCol => {
    const manualCol = manualMap.get(genCol.key);
    if (manualCol) {
      // Manual column takes precedence
      merged.push(manualCol);
      manualMap.delete(genCol.key);
    } else {
      // Use generated column
      merged.push(genCol);
    }
  });

  // Add any manual columns that weren't in generated set
  manualMap.forEach(col => {
    merged.push(col);
  });

  return merged;
}

/**
 * Helper: Validate generated columns
 */
export function validateColumns(columns: DataGridColumn[]): {
  valid: boolean;
  errors: string[];
} {
  const errors: string[] = [];

  // Check for duplicate keys
  const keys = new Set<string>();
  columns.forEach(col => {
    if (keys.has(col.key)) {
      errors.push(`Duplicate column key: ${col.key}`);
    }
    keys.add(col.key);
  });

  // Check for required fields
  columns.forEach(col => {
    if (!col.key) {
      errors.push('Column missing key');
    }
    if (!col.label) {
      errors.push(`Column ${col.key} missing label`);
    }
  });

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Convert generated columns to regular DataGridColumn[]
 * (strips metadata)
 */
export function stripMetadata(columns: GeneratedColumn[]): DataGridColumn[] {
  return columns.map(col => {
    const { _metadata, ...rest } = col;
    return rest;
  });
}

/**
 * Default column exclusions (columns typically hidden from grids)
 */
export const DEFAULT_EXCLUDED_COLUMNS = [
  'password',
  'password_hash',
  'salt',
  'token',
  'refresh_token',
  'secret',
  'private_key',
  'api_key',
];

/**
 * Get recommended column order for common tables
 */
export function getRecommendedColumnOrder(tableName: string): string[] | null {
  const orderMap: Record<string, string[]> = {
    users: ['id', 'display_name', 'email', 'created_at', 'updated_at'],
    profiles: ['id', 'user_id', 'display_name', 'avatar_url', 'created_at'],
    artists: ['id', 'name', 'genre', 'image_url', 'bio'],
    venues: ['id', 'name', 'city', 'state', 'capacity', 'image_url'],
    events: ['id', 'title', 'date', 'time', 'venue_id', 'status'],
    organizations: ['id', 'name', 'owner_id', 'profile_picture', 'created_at'],
  };

  return orderMap[tableName] || null;
}

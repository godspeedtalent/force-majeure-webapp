/**
 * Column Factory Service
 *
 * Generates DataGrid column definitions from database schema metadata.
 * Combines type mapping, relation detection, and customizations to create
 * fully-configured column objects.
 */
import { mapColumn, generateLabel, isSortableType, isFilterableType, isEditableType, getDefaultWidth, } from './schemaTypeMapper';
import { detectRelations, isRelationEditable, } from './relationDetector';
import { logger } from '@/shared';
/**
 * Generate a single column definition
 */
function generateColumn(mapped, relation, customization) {
    // Start with base properties from mapped column
    const column = {
        key: mapped.key,
        type: mapped.type,
        label: generateLabel(mapped.key),
        sortable: isSortableType(mapped.type),
        filterable: isFilterableType(mapped.type),
        editable: isEditableType(mapped.type, mapped.readonly),
        readonly: mapped.readonly,
        required: mapped.required,
        width: getDefaultWidth(mapped.type, mapped.key),
    };
    // Apply relation properties if detected
    if (relation) {
        column.isRelation = true;
        // If relation has a component, make it editable
        if (relation.hasComponent && !customization?.is_editable === false) {
            column.editable = isRelationEditable(relation);
        }
        else {
            // No component available - show as readonly text
            column.editable = false;
            column.readonly = true;
        }
    }
    // Apply customizations (overrides)
    if (customization) {
        if (customization.custom_label) {
            column.label = customization.custom_label;
        }
        if (customization.custom_type) {
            column.type = customization.custom_type;
        }
        if (customization.is_editable !== undefined) {
            column.editable = customization.is_editable;
        }
        if (customization.is_sortable !== undefined) {
            column.sortable = customization.is_sortable;
        }
        if (customization.is_filterable !== undefined) {
            column.filterable = customization.is_filterable;
        }
        if (customization.custom_width) {
            column.width = customization.custom_width;
        }
    }
    // Add metadata for debugging/inspection
    column._metadata = {
        source: customization ? 'customization' : 'schema',
        hasRelationComponent: relation?.hasComponent || false,
        referencedTable: relation?.referencedTable,
        postgresType: mapped.postgresType,
        isAutoGenerated: !customization,
    };
    return column;
}
/**
 * Main factory function: Generate columns from schema
 */
export function generateColumnsFromSchema(options) {
    const { tableName, columns: columnMetadata, foreignKeys = [], customizations = [], excludeColumns = [], includeColumns, readonly = false, defaultVisible = true, } = options;
    logger.info(`Generating columns for table: ${tableName}`, {
        columnCount: columnMetadata.length,
        foreignKeyCount: foreignKeys.length,
        customizationCount: customizations.length,
    });
    // Create customization lookup map
    const customizationMap = new Map();
    customizations.forEach(custom => {
        customizationMap.set(custom.column_key, custom);
    });
    // Detect all relations
    const columnNames = columnMetadata.map(col => col.name);
    const relations = detectRelations(columnNames, foreignKeys);
    const relationMap = new Map();
    relations.forEach(rel => {
        relationMap.set(rel.columnKey, rel);
    });
    // Log missing relation components as warnings
    const missingComponents = relations.filter(r => !r.hasComponent);
    if (missingComponents.length > 0) {
        logger.warn(`Table ${tableName} has ${missingComponents.length} foreign keys without relation components:`, missingComponents.map(r => `${r.columnKey} -> ${r.referencedTable}`));
    }
    // Generate columns
    const generatedColumns = [];
    for (const colMeta of columnMetadata) {
        // Check include/exclude filters
        if (excludeColumns.includes(colMeta.name)) {
            continue;
        }
        if (includeColumns && !includeColumns.includes(colMeta.name)) {
            continue;
        }
        // Map column type
        const mapped = mapColumn(colMeta);
        // Apply global readonly override
        if (readonly) {
            mapped.readonly = true;
        }
        // Get relation and customization
        const relation = relationMap.get(colMeta.name) || null;
        const customization = customizationMap.get(colMeta.name);
        // Generate column
        const column = generateColumn(mapped, relation, customization);
        // Apply default visibility (can be overridden by customization)
        if (customization?.is_visible_by_default !== undefined) {
            // Customization specifies visibility
            if (!customization.is_visible_by_default) {
                continue; // Skip invisible columns
            }
        }
        else if (!defaultVisible) {
            // Global default is invisible
            continue;
        }
        generatedColumns.push(column);
    }
    // Apply custom ordering if specified
    const columnsWithOrder = generatedColumns.map((col, index) => {
        const customization = customizationMap.get(col.key);
        return {
            column: col,
            order: customization?.display_order ?? index,
        };
    });
    // Sort by order
    columnsWithOrder.sort((a, b) => a.order - b.order);
    const finalColumns = columnsWithOrder.map(item => item.column);
    logger.info(`Generated ${finalColumns.length} columns for table: ${tableName}`, {
        withRelations: finalColumns.filter(c => c.isRelation).length,
        editable: finalColumns.filter(c => c.editable).length,
        readonly: finalColumns.filter(c => c.readonly).length,
    });
    return finalColumns;
}
/**
 * Helper: Get column by key
 */
export function getColumnByKey(columns, key) {
    return columns.find(col => col.key === key);
}
/**
 * Helper: Filter visible columns
 */
export function filterVisibleColumns(columns) {
    // Currently, all returned columns are visible
    // This is for future use with visibility toggle
    return columns;
}
/**
 * Helper: Reorder columns
 */
export function reorderColumns(columns, order) {
    const columnMap = new Map(columns.map(col => [col.key, col]));
    const reordered = [];
    // Add columns in specified order
    order.forEach(key => {
        const col = columnMap.get(key);
        if (col) {
            reordered.push(col);
            columnMap.delete(key);
        }
    });
    // Add remaining columns that weren't in order array
    columnMap.forEach(col => {
        reordered.push(col);
    });
    return reordered;
}
/**
 * Helper: Merge generated columns with manual overrides
 */
export function mergeWithManualColumns(generated, manual) {
    const manualMap = new Map(manual.map(col => [col.key, col]));
    const merged = [];
    // Start with generated columns, applying manual overrides
    generated.forEach(genCol => {
        const manualCol = manualMap.get(genCol.key);
        if (manualCol) {
            // Manual column takes precedence
            merged.push(manualCol);
            manualMap.delete(genCol.key);
        }
        else {
            // Use generated column
            merged.push(genCol);
        }
    });
    // Add any manual columns that weren't in generated set
    manualMap.forEach(col => {
        merged.push(col);
    });
    return merged;
}
/**
 * Helper: Validate generated columns
 */
export function validateColumns(columns) {
    const errors = [];
    // Check for duplicate keys
    const keys = new Set();
    columns.forEach(col => {
        if (keys.has(col.key)) {
            errors.push(`Duplicate column key: ${col.key}`);
        }
        keys.add(col.key);
    });
    // Check for required fields
    columns.forEach(col => {
        if (!col.key) {
            errors.push('Column missing key');
        }
        if (!col.label) {
            errors.push(`Column ${col.key} missing label`);
        }
    });
    return {
        valid: errors.length === 0,
        errors,
    };
}
/**
 * Convert generated columns to regular DataGridColumn[]
 * (strips metadata)
 */
export function stripMetadata(columns) {
    return columns.map(col => {
        const { _metadata, ...rest } = col;
        return rest;
    });
}
/**
 * Default column exclusions (columns typically hidden from grids)
 */
export const DEFAULT_EXCLUDED_COLUMNS = [
    'password',
    'password_hash',
    'salt',
    'token',
    'refresh_token',
    'secret',
    'private_key',
    'api_key',
];
/**
 * Get recommended column order for common tables
 */
export function getRecommendedColumnOrder(tableName) {
    const orderMap = {
        users: ['id', 'display_name', 'email', 'created_at', 'updated_at'],
        profiles: ['id', 'user_id', 'display_name', 'avatar_url', 'created_at'],
        artists: ['id', 'name', 'genre', 'image_url', 'bio'],
        venues: ['id', 'name', 'city', 'state', 'capacity', 'image_url'],
        events: ['id', 'title', 'date', 'time', 'venue_id', 'status'],
        organizations: ['id', 'name', 'owner_id', 'profile_picture', 'created_at'],
    };
    return orderMap[tableName] || null;
}
